<html>
  <head>
    <title>three.js</title>
    <style>
      body {
        margin: 0;
      }
      canvas {
        width: 100%;
        height: 100%;
      }
    </style>
  </head>
  <body>
		<div id="lbl_left" class="lbl">
		anisotropy: <span class="c" id="val_left"></span><br/>
		</div>

		<div id="lbl_right" class="lbl">
		anisotropy: <span class="c" id="val_right"></span><br/>
</div>
    <script src="three.js"></script>
    <script src="OBJloader.js"></script>
    <script src="mtl.js"></script>
    <script>
if ( WEBGL.isWebGLAvailable() === false ) {
				document.body.appendChild( WEBGL.getWebGLErrorMessage() );
			}
			var statsEnabled = true;
			var container, stats;
			var camera, scene, renderer, controls;
			init();
			animate();
			function init() {
				container = document.createElement( 'div' );
				document.body.appendChild( container );
				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );
				renderer.gammaInput = true;
				renderer.gammaOutput = true;
				renderer.toneMapping = THREE.ReinhardToneMapping;
				renderer.toneMappingExposure = 3;
				//
				scene = new THREE.Scene();
				camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.01, 1000 );
				camera.position.z = 2;
				controls = new THREE.TrackballControls( camera, renderer.domElement );
				//
				scene.add( new THREE.HemisphereLight( 0x443333, 0x222233, 4 ) );
				//
				var material = new THREE.MeshStandardMaterial();
				new THREE.OBJLoader()
					.load( 'cottage.obj', function ( group ) {
						var loader = new THREE.TextureLoader()
						// roughness is in G channel, metalness is in B channel
						material.metalnessMap = material.roughnessMap = loader.load( 'wood.png' );
						material.normalMap = loader.load( 'wood.png' );
						material.map.wrapS = THREE.RepeatWrapping;
						material.roughnessMap.wrapS = THREE.RepeatWrapping;
						material.metalnessMap.wrapS = THREE.RepeatWrapping;
						material.normalMap.wrapS = THREE.RepeatWrapping;
						group.traverse( function ( child ) {
							if ( child instanceof THREE.Mesh ) {
								child.material = material;
							}
						} );
						group.position.x = - 0.45;
						group.rotation.y = - Math.PI / 2;
						scene.add( group );
					} );
				// new THREE.CubeTextureLoader().setPath( './textures/cube/pisaRGBM16/' )
				// 	.load( [ 'px.png', 'nx.png', 'py.png', 'ny.png', 'pz.png', 'nz.png' ], function ( rgbmCubeMap ) {
				// 	rgbmCubeMap.encoding = THREE.RGBM16Encoding;
				// 	rgbmCubeMap.format = THREE.RGBAFormat;
				// 	var pmremGenerator = new THREE.PMREMGenerator( rgbmCubeMap );
				// 	pmremGenerator.update( renderer );
				// 	var pmremCubeUVPacker = new THREE.PMREMCubeUVPacker( pmremGenerator.cubeLods );
				// 	pmremCubeUVPacker.update( renderer );
				// 	var rgbmCubeRenderTarget = pmremCubeUVPacker.CubeUVRenderTarget;
				// 	material.envMap = rgbmCubeRenderTarget.texture;
				// 	material.needsUpdate = true; // is this needed?
				// 	rgbmCubeMap.magFilter = THREE.LinearFilter;
				// 	rgbmCubeMap.needsUpdate = true;
				// 	scene.background = rgbmCubeMap;
				// 	pmremGenerator.dispose();
				// 	pmremCubeUVPacker.dispose();
				// } );
				//
				if ( statsEnabled ) {
					stats = new Stats();
					container.appendChild( stats.dom );
				}
				window.addEventListener( 'resize', onWindowResize, false );
			}
			//
			function onWindowResize() {
				renderer.setSize( window.innerWidth, window.innerHeight );
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
			}
			//
			function animate() {
				requestAnimationFrame( animate );
				controls.update();
				renderer.render( scene, camera );
				if ( statsEnabled ) stats.update();
			}
    </script>
  </body>
</html>
